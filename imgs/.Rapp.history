for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density)$p.value#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test))#
}
data
density
Density
data
i=1
data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density)$p.value
w.test
wilcox.test(data,mu=Density)$p.value
wilcox.test(data,mu=Density)
data
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test))#
}
testcases
NW1<-testcases[,which(testcases[1,]=="NW1" & as.numeric(testcases[3,])>0)]
NW1
testcases<-estimatesmatrix[,which(estimatesmatrix[2,]=="Y")]#
NW1<-testcases[,which(testcases[1,]=="NW1" & as.numeric(testcases[3,])>0)]#
SW1<-testcases[,which(testcases[1,]=="SW1" & as.numeric(testcases[3,])>0)]#
NE1<-testcases[,which(testcases[1,]=="NE1" & as.numeric(testcases[3,])>0)]#
SE3<-testcases[,which(testcases[1,]=="SE3" & as.numeric(testcases[3,])>0)]
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,Density)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,Density)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,Density)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1.5,outer=TRUE)
setwd(DIR_IMG)#
pdf("ResultsNoCaptures.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1.5,outer=TRUE)#
dev.off()
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="%age error - between est. and true density",line=1.5,outer=TRUE)
mtext(side=2,text="percentage error - between est. and true density",line=1.5,outer=TRUE)
mtext(side=2,text="Ppar(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)ercentage error - between est. and true density",line=1.5,outer=TRUE)
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
setwd(DIR_IMG)#
pdf("ResultsNoCaptures.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COLset2[1])#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COLset2[2])#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COLset2[3])#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COLset2[4])#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
		w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
		    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
		datafortim<-matrix(ncol=102,nrow=0);#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
#
	TimeOfInterest<-14400#
#
	for(ModelNumber in 1:4){#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				#print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_SAVE)#
#pdf("ResultsPerching.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
	ModelSelection[2,]<-c(0,1.428 , "p343") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
#
	plot(0,0,type="n",#
		ylim=c(-5,5),xlim=c(0,1),#
		ylab="",xlab="Proportion of time spent stationary")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	legend(x=0,y=5,col=1:4,pch=rep(1,4), #
		legend=c(paste("Model",ModelSelection[1,3]),#
				paste("Model",ModelSelection[2,3]),#
				paste("Model",ModelSelection[3,3]),#
				paste("Model",ModelSelection[4,3])#
				)#
	)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=0, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.5,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.75,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)	#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#
#setwd(DIR_IMG)#
#pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		boxplot(d[1,],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1.5,outer=TRUE)#
#dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
#setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
#setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
Camera
Cameras
x
Speed
ModelSelection
Output<-vector(mode="list",length=4)#
	Data<-x[-c(1:4),-1]#
	header<-x[c(1:4),-1]#
	timerow		<-which(x[,1]=="Time")#
	sensorrow	<-which(x[,1]=="Sensor")#
	callrow		<-which(x[,1]=="Call")#
	densityrow	<-which(x[,1]=="Density")
Data
for(i in 1:4){#
		print(paste("I:",i))#
		CamerarowI	<-which(ModelSelection[i,1]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-as.numeric(ModelSelection[i,2])*2#
		print(paste("CamerarowI",CamerarowI,"CameraWidthI",CameraWidthI))#
		#Calculation of the profile width#
		profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
		#print(profilewidth)#
		selectedcols<-which(header[sensorrow,]==ModelSelection[i,1] & header[callrow,]== ModelSelection[i,2])#
		print(paste("ModelSelection[i,1]",ModelSelection[i,1],"ModelSelection[i,2]",ModelSelection[i,2]))#
		#print(paste("which(header[sensorrow,]==ModelSelection[i,1])",which(header[sensorrow,]==ModelSelection[i,1])))#
		#print(paste("which(header[callrow,]== ModelSelection[i,2])",which(header[callrow,] == ModelSelection[i,2])))#
		print(selectedcols)#
		TempOutput<-vector(mode="list",length=length(selectedcols))#
		for(time in 1:length(selectedcols)){#
			Column<-selectedcols[time]#
			TimeVal<-header[timerow,Column]*StepLength#
			DensityVal<-header[densityrow,Column]/Area#
#
			Numbvector<-Data[,Column]#
			Estvector<-(1/profilewidth[[1]])*Numbvector/(Speed*TimeVal)#
			Biasvector<-(Estvector-DensityVal)*(1000^2)#
			Percentvector<-100*Biasvector/(DensityVal*(1000^2))#
			print(paste("Speed",Speed,"Time",TimeVal,"Number", mean(Numbvector),"Estimate",mean(Estvector)))#
			print(paste("MinBias",min(Biasvector),"MaxBias",max(Biasvector)))#
			TempOutput[[time]]<-list(Time=TimeVal,#
									Numbers=Numbvector, #
									Bias = Biasvector, #
									Estimates = Estvector, #
									Percent = Percentvector)#
		}#
		Output[[i]] <-TempOutput#
	}
selectedcols
Data[,selectedcols]
Header[,selectedcols]
header[,selectedcols]
Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)
loadindata
loadindata[1:4,]
# For each model output list#
#
CalBias<-function(ModelSelection,Cameras, x, Speed ){#
	Output<-vector(mode="list",length=4)#
	Data<-x[-c(1:4),-1]#
	header<-x[c(1:4),-1]#
	timerow		<-which(x[,1]=="Time")#
	sensorrow	<-which(x[,1]=="Sensor")#
	callrow		<-which(x[,1]=="Call")#
	densityrow	<-which(x[,1]=="Density")#
	for(i in 1:4){#
		print(paste("I:",i))#
		CamerarowI	<-which(ModelSelection[i,1]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-as.numeric(ModelSelection[i,2])*2#
		print(paste("CamerarowI",CamerarowI,"CameraWidthI",CameraWidthI))#
		#Calculation of the profile width#
		profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
		#print(profilewidth)#
		selectedcols<-which(header[sensorrow,]==ModelSelection[i,1] & header[callrow,]== ModelSelection[i,2])#
		print(paste("ModelSelection[i,1]",ModelSelection[i,1],"ModelSelection[i,2]",ModelSelection[i,2]))#
		#print(paste("which(header[sensorrow,]==ModelSelection[i,1])",which(header[sensorrow,]==ModelSelection[i,1])))#
		#print(paste("which(header[callrow,]== ModelSelection[i,2])",which(header[callrow,] == ModelSelection[i,2])))#
		print(selectedcols)#
		selectedcols<-selectedcols[1]#
		TempOutput<-vector(mode="list",length=length(selectedcols))#
		for(time in 1:length(selectedcols)){#
			Column<-selectedcols[time]#
			TimeVal<-header[timerow,Column]*StepLength#
			DensityVal<-header[densityrow,Column]/Area#
#
			Numbvector<-Data[,Column]#
			Estvector<-(1/profilewidth[[1]])*Numbvector/(Speed*TimeVal)#
			Biasvector<-(Estvector-DensityVal)*(1000^2)#
			Percentvector<-100*Biasvector/(DensityVal*(1000^2))#
			print(paste("Speed",Speed,"Time",TimeVal,"Number", mean(Numbvector),"Estimate",mean(Estvector)))#
			print(paste("MinBias",min(Biasvector),"MaxBias",max(Biasvector)))#
			TempOutput[[time]]<-list(Time=TimeVal,#
									Numbers=Numbvector, #
									Bias = Biasvector, #
									Estimates = Estvector, #
									Percent = Percentvector)#
		}#
		Output[[i]] <-TempOutput#
	}#
	return(Output)#
}
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
#setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
#setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
d
boxplot(d)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[1,],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
d
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
?mtext
library(Hmisc)
library(Hmisc)
??tick
minor.tick(nx=2, ny=2, tick.ratio=0.5)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
minor.tick(nx=2, ny=2, tick.ratio=0.5)
minor.tick(nx=2, ny=0, tick.ratio=1)
?minor.tick
?axis
axis(2,lables=FALSE)
axis(2,labels=FALSE)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)#
#dev.off()
axis(2,labels=FALSE)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
		axis(2,labels=FALSE)#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(2,labels=FALSE)#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
?axis
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(2,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(1,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error",line=1,outer=TRUE)
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
		datafortim<-matrix(ncol=102,nrow=0);#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
#
	TimeOfInterest<-14400#
#
	for(ModelNumber in 1:4){#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				#print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_SAVE)#
#pdf("ResultsPerching.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
	ModelSelection[2,]<-c(0,1.428 , "p343") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
#
	plot(0,0,type="n",#
		ylim=c(-5,5),xlim=c(0,1),#
		ylab="",xlab="Proportion of time spent stationary")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	legend(x=0,y=5,col=1:4,pch=rep(1,4), #
		legend=c(paste("Model",ModelSelection[1,3]),#
				paste("Model",ModelSelection[2,3]),#
				paste("Model",ModelSelection[3,3]),#
				paste("Model",ModelSelection[4,3])#
				)#
	)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=0, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.5,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.75,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)	#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#
#setwd(DIR_IMG)#
#pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		boxplot(d[1,],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[1,])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
#dev.off()
#setwd(DIR_IMG)#
#pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-4,4),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
#dev.off()
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25,0.5,0.75) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
#dev.off()
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COLset2[i],axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
#DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
cols<-brewer.pal(9,"YlOrRd")#
ramp<-colorRampPalette(brewer.pal(11,"Spectral"))(500)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_IMG)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_IMG)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE)#
box()#
dev.off()#
### - P-values from Wilcoxon test#
setwd(DIR_IMG)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_IMG)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
COLset1=brewer.pal(9,"Set1")
COLset1
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("ModelSelect.R")#
source("subfunctions.R")#
#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[,1]<-c("NW1", COLset3[3])#
COLmodel[,1]<-c("SW1", COLset3[11])#
COLmodel[,1]<-c("NE1", COLset3[1])#
COLmodel[,1]<-c("SE3", COLset3[11])#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-5#100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,TestCounts6Aug.csv",header=FALSE)#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:3),-1]#
header<-x[c(1:3),-1]#
#
capsrow<-which(x[,1]=="Captures")#
sensorrow<-which(x[,1]=="Sensor")#
callrow<-which(x[,1]=="Call")#
estimatesmatrix<-matrix(nrow=dim(Data)[1]+3,ncol=dim(Data)[2])#
#
#for(i in 1:dim(Data)[2]){#
for(i in 1:836){#
	print(paste(i,"/",dim(Data)[2]))#
	profile<-cameraprofile(SensorNo=header[sensorrow,i], SensorInfo=Cameras, Callwidth=header[callrow,i]*2)[[1]]#
	model<-pickmodel(sensor=Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle*2,call=header[callrow,i]*2)#
	estimatesmatrix[1,i]<-model#
	print("model select")#
	if((header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)#
	){estimatesmatrix[2,i]<-"Y"}else{estimatesmatrix[2,i]<-"N"}#
	estimatesmatrix[3,i]<-header[capsrow,i]#
	print("time")#
	Time<-Data[,i]#
	print(mean(Time/(60*60)))#
	Captures<-header[capsrow,i]#
	estimatesmatrix[4:(dim(Data)[1]+3),i]<-((1/profile)*Captures/(Speed*Time))*(1000^2)#
}#
#
testcases<-estimatesmatrix[,which(estimatesmatrix[2,]=="Y")]#
NW1<-testcases[,which(testcases[1,]=="NW1" & as.numeric(testcases[3,])>0)]#
SW1<-testcases[,which(testcases[1,]=="SW1" & as.numeric(testcases[3,])>0)]#
NE1<-testcases[,which(testcases[1,]=="NE1" & as.numeric(testcases[3,])>0)]#
SE3<-testcases[,which(testcases[1,]=="SE3" & as.numeric(testcases[3,])>0)]#
PlusMinusPerError<-70#
#
maxval<-(dim(Data)[1]+3)#
yval<-10#
#
CV<-function(data){round(sd(data)/mean(data),2)}#
#
setwd(DIR_IMG)#
pdf("ResultsNoCaptures.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	model<-"NW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	model<-"SW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	model<-"SE3"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	model<-"NE1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
COL
COLmodel
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
#DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("ModelSelect.R")#
source("subfunctions.R")#
#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-5#100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,TestCounts6Aug.csv",header=FALSE)#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:3),-1]#
header<-x[c(1:3),-1]#
#
capsrow<-which(x[,1]=="Captures")#
sensorrow<-which(x[,1]=="Sensor")#
callrow<-which(x[,1]=="Call")#
estimatesmatrix<-matrix(nrow=dim(Data)[1]+3,ncol=dim(Data)[2])#
#
#for(i in 1:dim(Data)[2]){#
for(i in 1:836){#
	print(paste(i,"/",dim(Data)[2]))#
	profile<-cameraprofile(SensorNo=header[sensorrow,i], SensorInfo=Cameras, Callwidth=header[callrow,i]*2)[[1]]#
	model<-pickmodel(sensor=Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle*2,call=header[callrow,i]*2)#
	estimatesmatrix[1,i]<-model#
	print("model select")#
	if((header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)#
	){estimatesmatrix[2,i]<-"Y"}else{estimatesmatrix[2,i]<-"N"}#
	estimatesmatrix[3,i]<-header[capsrow,i]#
	print("time")#
	Time<-Data[,i]#
	print(mean(Time/(60*60)))#
	Captures<-header[capsrow,i]#
	estimatesmatrix[4:(dim(Data)[1]+3),i]<-((1/profile)*Captures/(Speed*Time))*(1000^2)#
}#
#
testcases<-estimatesmatrix[,which(estimatesmatrix[2,]=="Y")]#
NW1<-testcases[,which(testcases[1,]=="NW1" & as.numeric(testcases[3,])>0)]#
SW1<-testcases[,which(testcases[1,]=="SW1" & as.numeric(testcases[3,])>0)]#
NE1<-testcases[,which(testcases[1,]=="NE1" & as.numeric(testcases[3,])>0)]#
SE3<-testcases[,which(testcases[1,]=="SE3" & as.numeric(testcases[3,])>0)]#
PlusMinusPerError<-70#
#
maxval<-(dim(Data)[1]+3)#
yval<-10#
#
CV<-function(data){round(sd(data)/mean(data),2)}#
#
setwd(DIR_IMG)#
pdf("ResultsNoCaptures.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	model<-"NW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	model<-"SW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	model<-"SE3"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	model<-"NE1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()#
#
cols<-brewer.pal(9,"YlOrRd")#
ramp<-colorRampPalette(brewer.pal(11,"Spectral"))(500)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_IMG)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_IMG)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE)#
box()#
dev.off()#
### - P-values from Wilcoxon test#
setwd(DIR_IMG)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_IMG)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("ModelSelect.R")#
source("subfunctions.R")#
#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-5#100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,TestCounts6Aug.csv",header=FALSE)#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:3),-1]#
header<-x[c(1:3),-1]#
#
capsrow<-which(x[,1]=="Captures")#
sensorrow<-which(x[,1]=="Sensor")#
callrow<-which(x[,1]=="Call")#
estimatesmatrix<-matrix(nrow=dim(Data)[1]+3,ncol=dim(Data)[2])#
#
#for(i in 1:dim(Data)[2]){#
for(i in 1:836){#
	print(paste(i,"/",dim(Data)[2]))#
	profile<-cameraprofile(SensorNo=header[sensorrow,i], SensorInfo=Cameras, Callwidth=header[callrow,i]*2)[[1]]#
	model<-pickmodel(sensor=Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle*2,call=header[callrow,i]*2)#
	estimatesmatrix[1,i]<-model#
	print("model select")#
	if((header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.04720)||#
		(header[callrow,i] == 3.14159 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)||#
		(header[callrow,i] == 1.428 & Cameras[which(header[sensorrow,i]==Cameras$ID),]$HalfWidthAngle == 1.74533)#
	){estimatesmatrix[2,i]<-"Y"}else{estimatesmatrix[2,i]<-"N"}#
	estimatesmatrix[3,i]<-header[capsrow,i]#
	print("time")#
	Time<-Data[,i]#
	print(mean(Time/(60*60)))#
	Captures<-header[capsrow,i]#
	estimatesmatrix[4:(dim(Data)[1]+3),i]<-((1/profile)*Captures/(Speed*Time))*(1000^2)#
}#
#
testcases<-estimatesmatrix[,which(estimatesmatrix[2,]=="Y")]#
NW1<-testcases[,which(testcases[1,]=="NW1" & as.numeric(testcases[3,])>0)]#
SW1<-testcases[,which(testcases[1,]=="SW1" & as.numeric(testcases[3,])>0)]#
NE1<-testcases[,which(testcases[1,]=="NE1" & as.numeric(testcases[3,])>0)]#
SE3<-testcases[,which(testcases[1,]=="SE3" & as.numeric(testcases[3,])>0)]#
PlusMinusPerError<-70#
#
maxval<-(dim(Data)[1]+3)#
yval<-10#
#
CV<-function(data){round(sd(data)/mean(data),2)}#
#
setwd(DIR_IMG)#
pdf("ResultsNoCaptures.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
	box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NW1",side=3,line=0)#
for(i in 1:dim(NW1)[2]){#
	model<-"NW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SW1",side=3,line=0)#
for(i in 1:dim(SW1)[2]){#
	model<-"SW1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SW1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SW1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SW1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
#mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="SE3",side=3,line=0)#
for(i in 1:dim(SE3)[2]){#
	model<-"SE3"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(SE3[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(SE3[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(SE3[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
    sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
plot(0,0,type="n",xlim=c(1,yval),ylim=c(0-PlusMinusPerError,0+PlusMinusPerError),#
	ylab="",xlab="", axes=FALSE#
	,main="")#
box()#
abline(h=0,lty=2,col="grey")#
mtext(side=1,at=c(2,4,6,8,10),text=expression(20,40,60,80,100),line=1)#
mtext(side=2,at=c(-PlusMinusPerError,0,PlusMinusPerError),text=c(-PlusMinusPerError,0,PlusMinusPerError),line=1)#
mtext(text="NE1",side=3,line=0)#
for(i in 1:dim(NE1)[2]){#
	model<-"NE1"#
	COL<-COLmodel[which(COLmodel==model),2]#
	data<-as.numeric(NE1[4:maxval,i])#
	dataerr<-data - Density*1000^2#
	cv<-CV(data)#
	boxplot(dataerr,add=T, at=as.numeric(NE1[3,i])/10, axes=FALSE,col=COL)#
	text(x=as.numeric(NE1[3,i])/10,y=min(dataerr)-10, label=paste("CV = ",cv ),cex=0.8)#
	w.test<-wilcox.test(data,mu=Density*1000^2)$p.value#
	sig.value<-0.05/dim(SE3)[2]; if(w.test<sig.value){sig<-"yes"}else{sig<-"no"}#
	print(paste("Number of caps:",as.numeric(NW1[3,i])/10 ,"CV",sd(data)/mean(data), " p-value: ", w.test, " significant ", sig))#
}#
#
mtext(side=1,text="Number of captures",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
#DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_IMG)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_IMG)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE)#
box()#
dev.off()#
### - P-values from Wilcoxon test#
setwd(DIR_IMG)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_IMG)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
??ramp
ramp<-colorRamp(COLred)
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
#DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
ramp<-colorRamp(COLred)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_IMG)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_IMG)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE)#
box()#
dev.off()#
### - P-values from Wilcoxon test#
setwd(DIR_IMG)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_IMG)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
ramp<-colorRamp(COLred)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_SAVE)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_SAVE)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE)#
box()#
dev.off()#
### - P-values from Wilcoxon test#
setwd(DIR_SAVE)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_SAVE)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
setwd(DIR_IMG)#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
?image.plot
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1)#
box()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1, legend.args=c(1,2,3,4,5,6,7))#
box()
range((min(MatrixSD),max(MatrixSD))
range(min(MatrixSD),max(MatrixSD))
range(MatrixSD)
seq(min(MatrixSD),max(MatrixSD),5*10^-7)
seq(min(MatrixSD),max(MatrixSD),6*10^-7)
seq(min(MatrixSD),max(MatrixSD),10*10^-7)
seq(min(MatrixSD),max(MatrixSD),8*10^-7)
seq(min(MatrixSD),max(MatrixSD),4*10^-7)
seq(min(MatrixSD),max(MatrixSD),8*10^-7)
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7)
)
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),7)
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			lables = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)#
		)#
		)#
box()
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)#
		)#
		)#
box()
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),#
			cex.axis=0.6#
		)#
		)#
box()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),#
			cex.axis=0.9#
		)#
		)#
box()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)#
		)#
		)#
box()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 0.6,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)#
		)#
		)#
box()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),cex.axis=0.9#
		)#
		)#
box()
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)*10^7
round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8)*10^6
?expression
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10",^6))
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10",^6,sep=""))
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep=""))
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep="")),cex.axis=0.9#
		)#
		)#
box()
length(expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep="")))
seq(min(MatrixSD),max(MatrixSD),8*10^-7)
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-sequence[i]*10^-7#
	labs<-c(labs,expression(paste(leg,8),"x10"^6,sep="")))#
}
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-sequence[i]*10^-7#
	labs<-c(labs,expression(paste(leg,8),"x10"^6,sep=""))#
}
labs
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
length(labs)
expression(paste(leg,8),"x10"^6,sep="")
length(expression(paste(leg,8),"x10"^6,sep=""))
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-sequence[i]*10^-7#
	labs<-c(labs,expression(paste(leg,"x10"^6,sep="")))#
}
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
leg
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste(leg,"x10"^6,sep="")))#
}
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste(round(sequence[i]*10^-7,8),"x10"^6,sep="")))#
}
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
leg
leg<-round(sequence[i]*10^-7,8)
leg
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste(substitue(leg),"x10"^6,sep="")))#
}
leg
labs
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
?bquote
a <- 2#
#
bquote(a == a)#
quote(a == a)#
#
bquote(a == .(a))#
substitute(a == A, list(A = a))#
#
plot(1:10, a*(1:10), main = bquote(a == .(a)))#
#
## to set a function default arg#
default <- 1#
bquote( function(x, y = .(default)) x+y )
a <- 2#
#
bquote(a == a)#
quote(a == a)#
#
bquote(a == .(a))#
substitute(a == A, list(A = a))#
#
plot(1:10, a*(1:10), main = bquote(a == .(a)))#
#
## to set a function default arg#
default <- 1#
bquote( function(x, y = .(default)) x+y )
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste(bquote( .(leg)),"x10"^6,sep="")))#
}
labs
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste(== leg,"x10"^6,sep="")))#
}
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression(paste( == leg,"x10"^6,sep="")))#
}
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,expression( == leg x10"^6))#
}
substitue(leg)
substitute(leg)
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,substitute(expression(paste(leg,"x10"^6,sep=""))))#
}
labs
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i]*10^-7,8)#
	labs<-c(labs,substitute(expression(paste(leg,"x10"^6,sep=""))))#
}leg
leg
round(sequence[i]*10^-7,8)
round(sequence[i]*10^-7,9)
round(sequence[i])
sequence[i]
round(sequence[i],9)
round(sequence[i],9)*10&7
round(sequence[i],9)*10^7
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10")#
	labs<-c(labs,expression(leg^6,sep=""))#
}
labs
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
length(labs)
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10")#
	labs<-c(labs,expression(leg^6,sep=""))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10")#
	labs<-c(labs,bquote(.(leg)^6,sep=""))#
}
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10")#
	labs<-c(labs,bquote(.(leg)^6))#
}
labs
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,bquote(.(leg)^6))#
}
labs
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.9#
		)#
		)
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.6#
		)#
		)
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,expression(.(leg)^6))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,expression(bquote(.(leg))^6))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,expression(bquote(.(leg))^6))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,expression(bquote(.(leg))^6))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.6#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-c()#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,substitute(expression(leg^6)))#
}
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs<-c(labs,substitute(expression(leg^6)))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.6#
		)#
		)#
box()
labs
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(leg^6))#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.6#
		)#
		)#
box()
leg
labs<-vector('expression',number.leg)
labs
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))#
}
leg
substitute(expression(LEG^6),list(LEG=leg))
substitute(expression(LEG^6),list(LEG=leg))[2]
substitute(expression(LEG^6),list(LEG=leg))[1]
substitute(expression(LEG^6),list(LEG=leg))[2]
[2sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
]
[2sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}
labs
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.6#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],9)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.7#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^7#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.7#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.7#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.9#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Call width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab="Sensor width", ylab="Signal width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width",alpha))#
			, ylab="Signal width"#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",alpha))#
			, ylab=expression(paste("Signal width, ",theta))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
#setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)
setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
		datafortim<-matrix(ncol=102,nrow=0);#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
#
	TimeOfInterest<-14400#
#
	for(ModelNumber in 1:4){#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				#print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_SAVE)#
#pdf("ResultsPerching.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
	ModelSelection[2,]<-c(0,1.428 , "p343") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
#
	plot(0,0,type="n",#
		ylim=c(-5,5),xlim=c(0,1),#
		ylab="",xlab="Proportion of time spent stationary")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	legend(x=0,y=5,col=1:4,pch=rep(1,4), #
		legend=c(paste("Model",ModelSelection[1,3]),#
				paste("Model",ModelSelection[2,3]),#
				paste("Model",ModelSelection[3,3]),#
				paste("Model",ModelSelection[4,3])#
				)#
	)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=0, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.5,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.75,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)	#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#
#setwd(DIR_IMG)#
#pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
#dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
		datafortim<-matrix(ncol=102,nrow=0);#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
#
	TimeOfInterest<-14400#
#
	for(ModelNumber in 1:4){#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				#print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_SAVE)#
#pdf("ResultsPerching.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
	ModelSelection[2,]<-c(0,1.428 , "p343") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
#
	plot(0,0,type="n",#
		ylim=c(-5,5),xlim=c(0,1),#
		ylab="",xlab="Proportion of time spent stationary")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	legend(x=0,y=5,col=1:4,pch=rep(1,4), #
		legend=c(paste("Model",ModelSelection[1,3]),#
				paste("Model",ModelSelection[2,3]),#
				paste("Model",ModelSelection[3,3]),#
				paste("Model",ModelSelection[4,3])#
				)#
	)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=0, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.5,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.75,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)	#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#
setwd(DIR_IMG)#
pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
setwd(DIR_IMG)#
pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"
setwd(DIR_IMG)#
pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"
setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
ramp<-colorRamp(COLred)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[10],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_SAVE)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_SAVE)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()#
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep=""))#
### - P-values from Wilcoxon test#
setwd(DIR_SAVE)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_SAVE)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
setwd(DIR_IMG)#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2) ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
rnage(MatrixSD)
range(MatrixSD)
range(MatrixSD)*10^6
range(MatrixSD)*10^5
range(MatrixSD)*10^7
range(MatrixSD)*10^6
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				sig.value<-0.05/dim(ChoosenPts)[1]; if(w.test<sig.value){sig<-"yes"} else{"no"}#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test, " signifcant ", sig ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)
sig.value
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				sig.value<-0.05/dim(ChoosenPts)[1]; if(w.test<sig.value){sig<-"yes"} else{sig<-"no"}#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test, " signifcant ", sig ))#
			}#
		}#
	}#
}
0.01/25
0.04/25
0.05/25
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[9],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				sig.value<-0.05/dim(ChoosenPts)[1]; if(w.test<sig.value){sig<-"yes"} else{sig<-"no"}#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test, " signifcant ", sig ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
ramp<-colorRamp(COLred)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[9],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_SAVE)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_SAVE)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()#
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep=""))#
### - P-values from Wilcoxon test#
setwd(DIR_SAVE)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_SAVE)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
setwd(DIR_IMG)#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				sig.value<-0.05/dim(ChoosenPts)[1]; if(w.test<sig.value){sig<-"yes"} else{sig<-"no"}#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test, " signifcant ", sig ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
sig.value
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
		datafortim<-matrix(ncol=102,nrow=0);#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
#
	TimeOfInterest<-14400#
#
	for(ModelNumber in 1:4){#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				#print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_SAVE)#
#pdf("ResultsPerching.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
	ModelSelection[2,]<-c(0,1.428 , "p343") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
#
	plot(0,0,type="n",#
		ylim=c(-5,5),xlim=c(0,1),#
		ylab="",xlab="Proportion of time spent stationary")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	legend(x=0,y=5,col=1:4,pch=rep(1,4), #
		legend=c(paste("Model",ModelSelection[1,3]),#
				paste("Model",ModelSelection[2,3]),#
				paste("Model",ModelSelection[3,3]),#
				paste("Model",ModelSelection[4,3])#
				)#
	)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0.25,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=0, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.5,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0.75,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)	#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Perch	 <-Settings[which(Settings[,1] %in% "Perch"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Perch)#
	datafortim<-rbind(datafortim,temp)#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#
setwd(DIR_IMG)#
pdf("ResultsPerch.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,0.75*5+0.2),#
		ylab="",xlab="", axes=FALSE#
		,main="")#
			box()#
	#mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
	axis(1,labels=FALSE,at=c(0,0.25*5,0.5*5,0.75*5) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	box()#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j]*5,add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,0.25*5,0.5*5,0.75*5),text=expression(0,0.25,0.5,0.75),line=1)#
mtext(side=1,text="Proportion of time spent stationary",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
source("LoadIn.R")#
setwd(DIR_CODE)#
source("Output.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
COLmodel<-matrix(ncol=2,nrow=4)#
COLmodel[1,]<-c("NW1", COLset3[3])#
COLmodel[2,]<-c("SW1", COLset3[11])#
COLmodel[3,]<-c("NE1", COLset3[1])#
COLmodel[4,]<-c("SE3", COLset3[11])#
##################################
# Functions						##
##################################
#
PlotAddpoint<-function(x, Cameras,ModelSelect, NoOfSteps, Speed, Xval){#
	datafortim<-matrix(ncol=102,nrow=0);#
	print("PlotAddpoint")#
	if(ModelSelect ==1){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(0,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(0,1.428 , "p343") # #
		ModelSelection[3,]<-c(1,3.14159, "p221") # #
		ModelSelection[4,]<-c(1,1.428 , "p322") # #
	} else if(ModelSelect == 0){#
		ModelSelection<-matrix(nrow=4,ncol=3)#
		ModelSelection[1,]<-c(2,3.14159, "p141") # REM#
		ModelSelection[2,]<-c(2,1.428 , "p343") # #
		ModelSelection[3,]<-c(4,3.14159, "p221") # #
		ModelSelection[4,]<-c(4,1.428 , "p322") # #
	}#
#
	Output<-CalBias(ModelSelection, Cameras,x, Speed)#
	print("Finished Output")#
	TimeOfInterest<-14400#
	#TimeOfInterest<-NoOfSteps/2#
#
	for(ModelNumber in 1:4){#
		print(paste("ModelNumber:", ModelNumber))#
		model<-Output[[ModelNumber]]#
		for(number in 1:length(model)){#
			print(paste("number:", number,"model[[number]]$Time",model[[number]]$Time))#
			if(model[[number]]$Time==TimeOfInterest*(900)){#
				meanbias<-mean(model[[number]]$Percent,na.rm=T)#
				sdbias<-sd(model[[number]]$Percent,na.rm=T)	#
				sebias<-sdbias/10#
				print(paste("Inside plot",number, "ModelNumber",ModelNumber, "meanbias",meanbias,"sdbias",sdbias))#
				temp<-matrix(ncol=102,nrow=1,c(ModelNumber,Xval,model[[number]]$Percent));#
				datafortim<-rbind(datafortim,temp)#
				w.test<-wilcox.test(model[[number]]$Bias,mu=0)$p.value#
				print(paste("test value: ", w.test))#
				#plotCI(x=Xval,meanbias,uiw=sebias*1.96,col=ModelNumber,add=T)#
				boxplot(model[[number]]$Percent,add=T,at=Xval)#
			}	#
		}#
	}#
	return(datafortim)#
}#
##################################
# Plot				##
##################################
setwd(DIR_IMG)#
#pdf("ResultsTort.pdf")#
	datafortim<-matrix(ncol=102,nrow=0);#
	ModelSelection<-matrix(nrow=4,ncol=3)#
	ModelSelection[1,]<-c(0,3.14159, "REM") # REM#
	ModelSelection[2,]<-c(0,1.428 , "") # #
	ModelSelection[3,]<-c(1,3.14159, "p221") # #
	ModelSelection[4,]<-c(1,1.428 , "p322") # #
	par(mfrow=c(4,1))#
	plot(0,0,type="n",#
		ylim=c(-5,5),#
		xlim=c(-0.5,pi),#
		ylab="",xlab="Angle of correlated walk")#
	mtext(text=expression(paste("Percentage error")),side=2,line=2)#
	#legend(x=0,y=5,col=1:4,pch=rep(1,4), #
	#	legend=c(paste("Model",ModelSelection[1,3]),#
	#			paste("Model",ModelSelection[2,3]),#
	#			paste("Model",ModelSelection[3,3]),#
	#			paste("Model",ModelSelection[4,3])#
	#			)#
	#)#
	abline(h=0,lty=2,col="grey")#
	box()#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=3.14159"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=1.0472"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=2.0944"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras,ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
	Name<-"Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0"#
	setwd(DIR_DATA)#
	Settings<-read.csv(paste(Name,",Settings.csv",sep=""))#
	Cameras<-read.csv(paste(Name,",Sensors.csv",sep=""))#
	NoOfSteps<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
	Tort	 <-Settings[which(Settings[,1] %in% "CorrWalkMaxAngleChange"),2]	#
	Speed<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
	loadindata<-read.csv(paste(Name,",timenosubs14400.csv",sep=""),header=FALSE)#
	x<-loadindata[,-dim(loadindata)[2]]#
	temp<-PlotAddpoint(x, Cameras, ModelSelect=1, NoOfSteps, Speed, Tort)#
	datafortim<-rbind(datafortim,temp)#
#
#dev.off()#
#
model<-c("NW1","SW1","SE3","NE1")#
#xlab="Maximum change in direction at each step (radians)"#
#
setwd(DIR_IMG)#
pdf("ResultsTort.pdf")#
par(mfrow=c(4,1),oma=c(3,3,0,0), mar=c(2,4,2,0.5))#
for(i in 1:4){#
	COL<-COLmodel[which(COLmodel[,1]==model[i]),2]#
	plot(0,0,type="n",#
		ylim=c(-6,6),#
		xlim=c(-0.2,pi+0.2),#
		axes=FALSE,#
		ylab="",xlab=""#
		,main="")#
	box()#
	axis(1,labels=FALSE,at=c(0,pi/3,2*pi/3,pi) )#
	axis(2,labels=FALSE,at=c(-4,0,4) )#
#
	#mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
	mtext(side=2,at=c(-4,0,4),text=expression(-4,0,4),line=1)#
	mtext(text=model[i],side=3,line=0)#
	v<-vector(length=4)#
	temp<-datafortim[which(datafortim[,1]==i),]#
	tort<-sort(unique(temp[,2]))#
	for(j in 1:length(tort)){#
		d<-temp[which(temp[,2]==tort[j]),2:102]#
		d<-as.matrix(d)#
		boxplot(d[,1],at=tort[j],add=T,col=COL,axes=FALSE)#
		v[j]<-var(d[,1])#
	}#
	print(v)#
	#print(var.test(temp[which(temp[,2]==tort[4]),2:102],temp[which(temp[,2]==tort[1]),2:102],alternative="greater"))#
	abline(h=0,col="grey",lty=2)#
}#
mtext(side=1,at=c(0,pi/3,2*pi/3,pi),text=expression(0,pi/3,2*pi/3,pi),line=1)#
mtext(side=1,text="Maximum change in direction at each step (radians)",line=1.5,outer=TRUE)#
mtext(side=2,text="Percentage error between estimated and true density",line=1.5,outer=TRUE)#
dev.off()
##########################################################################
# Project title: Calculating denisty of animals from number of captures ##
# Project: Bat Project					                            	##
#                                                                   	##
# Author: Elizabeth Moorcroft                                       	##
# Date created: Who knows?!                                         	##
#                                                                  	 	##
# Edited by: -                                                     		##
# Edited on: -			                                            	##
#                                                                   	##
# Script title: Density calculation	         	                    	##
# Script purpose:Calculate the density form the simulation using		##
#                  - Tim's Function	(Not implemented)			        ##
#                  - Marcus' Function                    				##
#                                                                   	##
##########################################################################
rm(list=ls(all=TRUE)) #
#
######################
# Libraries 		##
######################
library("RColorBrewer")#
library("plotrix")#
library(fields)#
######################
# Directory			##
######################
DIR_DATA<-"/Users/student/Documents/Bats/Simulations"#
DIR_SAVE<-"/Users/student/Documents/Bats/Simulations"#
DIR_IMG<-"/Users/student/Documents/Bats/lucasMoorcroftManuscript/imgs"#
#DIR_IMG<-"/Users/student/Documents/Bats/Temp"#
DIR_CODE<-"/Users/student/Documents/Bats/R analysis code"#
######################
# Source code		##
######################
setwd(DIR_CODE)#
source("Tim's original bat code.R")#
source("calculateProfileWidth.R")#
######################
# Colours 			##
######################
COLset1=brewer.pal(9,"Set1")#
COLset2=brewer.pal(8,"Set2")#
COLset3=brewer.pal(12,"Set3")#
COLsets=rep(c(COLset1,COLset2,COLset3),4)#
#
##reds for SD#
COLred = brewer.pal(9,"Reds")#
#
##Colours match Tims graph#
COLMATCHGRAPH<- c( COLset3[1], COLset3[12], COLset3[6], COLset3[4], COLset3[5], COLset3[3], COLset3[8], COLset3[11])#
#
ramp<-colorRamp(COLred)#
#
##################################
# Load in Settings				##
##################################
setwd(DIR_DATA)#
Settings<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Settings.csv")#
Cameras<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,Sensors.csv")#
#
##################################
# Setting variables				##
##################################
NoOfIterations	<-100 #Settings[which(Settings[,1] %in% "NoOfIterations"),2]#
Seed			<-Settings[which(Settings[,1] %in% "Seed"),2]#
NoOfSteps		<-Settings[which(Settings[,1] %in% "NoSteps"),2]#
StepLength		<-Settings[which(Settings[,1] %in% "StepLength"),2]#
CameraCallRadius<-Settings[which(Settings[,1] %in% "DetectorRadius"),2]#
CameraSpeed		<-Settings[which(Settings[,1] %in% "SpeedCamera"),2]#
Speed			<-Settings[which(Settings[,1] %in% "AnimalSpeed"),2]#
NoofAnimals		<-Settings[which(Settings[,1] %in% "NoOfAnimals"),2]#
Area			<-Settings[which(Settings[,1] %in% "Area"),2]#
LengthMonitoring<-Settings[which(Settings[,1] %in% "LengthMonitoring"),2]#
Time			<-NoOfSteps*StepLength#
Density			<-NoofAnimals/(Area)#
#
##################################
# Load Data						##
##################################
loadindata<-read.csv("Run23Oct201317July0,Density=70,Speed=0.46,Iterations=1-101,StepLength=900,CorrWalkMaxAngleChange=0,timenosubs14400.csv",header=FALSE)#
#
x<-loadindata[,-dim(loadindata)[2]]#
#
Data<-x[-c(1:4),-1]#
header<-x[c(1:4),-1]#
callwidth<-names(table(as.numeric(header[2,])))#
radii<-names(table(as.numeric(Cameras[,6])))#
camerawidth<-names(table(as.numeric(Cameras[,5])))#
dimension<-dim(Data)[2]#
#
Matrix				<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(Matrix)	<-callwidth; rownames(Matrix)<-camerawidth#
MatrixNum			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixNum)	<-callwidth; rownames(MatrixNum)<-camerawidth#
MatrixSD			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixSD)	<-callwidth; rownames(MatrixSD)<-camerawidth#
MatrixTest			<-matrix(nrow=length(camerawidth),ncol=length(callwidth))#
colnames(MatrixTest)<-callwidth; rownames(MatrixTest)<-camerawidth#
#
for(i in 12:dim(Data)[2]){#
#for(i in 1:84){#
	print(paste("I:",i))#
	CamerarowI	<-which(header[1,i]==Cameras[,1])	#
	CameraWidthI<-Cameras[CamerarowI,5]*2	#
	CameraRadiI	<-Cameras[CamerarowI,6]#
	CallAngleI	<-header[2,i]*2#
	print(paste("Callangle",CallAngleI,"Camerawidth",CameraWidthI))#
	profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
	#print(paste("profilewidth:", profilewidth[[1]]))#
	tempest<-c()#
	tempdata<-c()#
	tempper<-c()#
	for(j in 1:dim(Data)[1]){		#
		if(Data[j,i]==0){tempest<-c(tempest,0)}#
		else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
		tempdata<-c(tempdata,Data[j,i])#
	}#
#
	m<-mean(tempest,na.rm=T)#
	sd1<-sd(tempest,na.rm=T)#
	p<-100*(tempest-Density)/Density#
	#print(summary(tempest))#
	if(CameraRadiI==10){			#
		rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
		colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
		#print(paste("HELLO", rownum, colnum))#
		Matrix[rownum,colnum]<-m#
		MatrixNum[rownum,colnum]<-mean(tempdata)#
		MatrixSD[rownum,colnum]<-sd1#sd(p,na.rm=T)#
		MatrixTest[rownum,colnum]<-wilcox.test(tempest[-c(1,length(tempest))],Density)$p.value#
#
	}#
}#
###  - Models Selected for the analysis#
ChoosenPts<-matrix(ncol=4,nrow=25)#
ChoosenPts[1,]<-c(camerawidth[1],callwidth[1],"SW7", 8) #"p344"#
ChoosenPts[2,]<-c(camerawidth[1],callwidth[2],"SW8", 8)#"p345"#
ChoosenPts[3,]<-c(camerawidth[2],callwidth[1],"SW4", 8)#"p341"#
ChoosenPts[4,]<-c(camerawidth[2],callwidth[3],"SW5", 8)#"p342"#
ChoosenPts[5,]<-c(camerawidth[1],callwidth[3],"SW9", 8)#"p346"#
ChoosenPts[6,]<-c(camerawidth[1],callwidth[5],"SW6", 8)#"p343"#
ChoosenPts[7,]<-c(camerawidth[1],callwidth[6], "NW7" ,6)#"p243"#
ChoosenPts[8,]<-c(camerawidth[1],callwidth[9],"NW6" ,6)#"p242"#
ChoosenPts[9,]<-c(camerawidth[1],callwidth[10], "NW5" ,6)#"p241"#
ChoosenPts[10,]<-c(camerawidth[1],callwidth[11],"REM",5) #"p141"#
ChoosenPts[11,]<-c(camerawidth[3],callwidth[1], "SW3",8) #"p333"#
ChoosenPts[12,]<-c(camerawidth[3],callwidth[3], "SW2",8)#"p332"#
ChoosenPts[13,]<-c(camerawidth[3],callwidth[5], "SW1",8)#"p331"#
ChoosenPts[14,]<-c(camerawidth[3],callwidth[6],"NW4",6) #"p233"#
ChoosenPts[15,]<-c(camerawidth[3],callwidth[9],"NW3",6) #"p232"#
ChoosenPts[16,]<-c(camerawidth[3],callwidth[10],"NW2",6) #"p231"#
ChoosenPts[17,]<-c(camerawidth[3],callwidth[11],"NW1",5) #"p131"#
ChoosenPts[18,]<-c(camerawidth[5],callwidth[1],"SE4",8)#"p323"#
ChoosenPts[19,]<-c(camerawidth[5],callwidth[5],"SE3",8)#"p322"#
ChoosenPts[21,]<-c(camerawidth[6],callwidth[5],"SE2",7)#"p321"#
ChoosenPts[20,]<-c(camerawidth[5],callwidth[6],"NE3",6)#"p223"#
ChoosenPts[22,]<-c(camerawidth[6],callwidth[6],"NE2",3)#"p222"#
ChoosenPts[23,]<-c(camerawidth[6],callwidth[9],"NE1",1)#"p221"#
ChoosenPts[24,]<-c(camerawidth[7],callwidth[1],"SE1",2)#"p311"#
ChoosenPts[25,]<-c(camerawidth[7],callwidth[10],"gas",4)#
### - Avergae bias shown in filled contour#
setwd(DIR_SAVE)#
pdf("AverageBias.pdf")#
filled.contour(z=Matrix -Density,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Average bias")#
dev.off()#
#
### - SD shown in filled contour#
setwd(DIR_SAVE)#
pdf("StandardDeviationContour.pdf")#
filled.contour(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="Standard Deviation")#
dev.off()#
#
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^-6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.8#
		)#
		)#
box()#
#
dev.off()#
expression(paste(round(seq(min(MatrixSD),max(MatrixSD),8*10^-7),8),"x10"^6,sep=""))#
### - P-values from Wilcoxon test#
setwd(DIR_SAVE)#
pdf("P-Values.pdf")#
filled.contour(z=MatrixTest,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, color.palette=colorRampPalette(brewer.pal(11,"Spectral"),space="Lab")#
			, xlab="Sensor width", ylab="Call width",main="P-Value, H0: Bias = 0")#
dev.off()#
#
### - The estimated error, with lines showing sub model devisions. #
###		With the all the combinations calculated, shown with circles#
###		and the models shown later with stars in the circles #
setwd(DIR_SAVE)#
pdf("Models.pdf")#
image(z=Matrix,x=as.numeric(camerawidth),y=as.numeric(callwidth), col=ramp,ylim=c(0,pi))#
	# Lines for the models #
	points(type="l", x=c(0,pi),y=c(pi,pi))#
	points(type="l", x=c(0,pi),y=c(pi/2,pi/2))#
	points(type="l", x=c(pi/2,pi/2),y=c(0,pi))#
	points(type="l", x=c(pi,pi),y=c(0,pi))#
	points(type="l", x=c(0,0),y=c(0,pi))#
	points(type="l", x=c(pi/4,pi/4),y=c(0,pi))#
	points(type="l", x=c(0,pi),y=c(pi,0))#
	points(type="l", x=c(0,pi/4),y=c(pi,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(pi,pi/2))#
	points(type="l", x=c(pi/2,pi),y=c(pi,0))#
	points(type="l", x=c(pi/2,pi),y=c(pi,pi/2))#
	points(type="l", x=c(0,pi/4),y=c(pi/2,0))#
	points(type="l", x=c(0,pi/4),y=c(0,pi/2))#
	points(type="l", x=c(0,pi/2),y=c(0,pi/2))#
	points(type="l", x=c(pi/4,pi/2),y=c(0,pi/2))#
	# Plots the circles of all models and the stars for the models used later#
	grid<-expand.grid(as.numeric(camerawidth),as.numeric(callwidth))#
	points(grid)#
	points(ChoosenPts,pch="*")#
dev.off()#
### - Boxplots for each model#
setwd(DIR_IMG)#
pdf("AverageModelBias.pdf")#
plot(type="n",0,0,xlab="Model Number",ylab="",xlim=c(1,26),ylim=c(-15,15),axes=FALSE)#
abline(h=0,col="grey",lty=2)#
modelcount=1#
for(model in 1:dim(ChoosenPts)[1]){#
	print(paste("Model: ", model,"/",dim(ChoosenPts)[1],sep=""))#
	for(i in 1:dim(Data)[2]){#
		#print(paste("I:",i))#
		CamerarowI	<-which(header[1,i]==Cameras[,1])	#
		CameraWidthI<-Cameras[CamerarowI,5]*2	#
		CameraRadiI	<-Cameras[CamerarowI,6]#
		CallAngleI	<-header[2,i]*2#
		examplept<-which(CameraWidthI/2 == as.numeric(ChoosenPts[model,1]) & CallAngleI/2 == as.numeric(ChoosenPts[model,2]))#
		if(length(examplept)>0){#
			profilewidth<-calcProfileWidth(CallAngleI, CameraWidthI, CameraRadiI )#
			tempest<-c()#
			tempdata<-c()#
			for(j in 1:dim(Data)[1]){#
				if(Data[j,i]==0){tempest<-c(tempest,0)}#
				else{tempest<-c(tempest,(1/profilewidth[[1]])*Data[j,i]/(Speed*Time))}#
				tempdata<-c(tempdata,Data[j,i])#
			}#
#
			if(CameraRadiI==10){			#
				rownum<-which(abs(as.numeric(camerawidth) - CameraWidthI/2)<0.1)#
				colnum<-which(abs(as.numeric(callwidth) - CallAngleI/2)<0.1)#
				Values<-tempest*(1000^2)- Density*(1000^2)#
				#print(Values)#
				Values<-100*Values/(Density*(1000^2))#
				sdadj<-sd(Values,na.rm=T)#
				meanadj<-mean(Values,na.rm=T) #
				stardarderr<-sdadj/sqrt(NoOfIterations)#
				#plotCI(x=modelcount,y=meanadj,uiw=(1.96*stardarderr),add=T)#
				boxplot(at=model,Values,add=T,axes=FALSE,col=COLMATCHGRAPH[as.numeric(ChoosenPts[model,4])])#
				modelcount=modelcount+1#
				w.test<-wilcox.test(tempest*(1000^2), mu= Density*(1000^2))$p.value#
				sig.value<-0.05/dim(ChoosenPts)[1]; if(w.test<sig.value){sig<-"yes"} else{sig<-"no"}#
				print(paste("InexamplePt",ChoosenPts[model,3],round(meanadj),round(stardarderr,2), " p-value ", w.test, " signifcant ", sig ))#
			}#
		}#
	}#
}#
axis(side=1,at=c(1:dim(ChoosenPts)[1]),labels=ChoosenPts[,3],las=2)#
axis(side=2,at=c(-15,-10,-5,0,5,10,15),labels=c(-15,-10,-5,0,5,10,15),las=0)#
mtext(text=expression(paste("Percentage error",sep="")),side=2,line=2)#
box()#
dev.off()
### - SD in blocks#
setwd(DIR_IMG)#
pdf("ResultStandardDeviation.pdf")#
#
sequence<-seq(min(MatrixSD),max(MatrixSD),8*10^-7)#
number.leg<-length(sequence)#
labs<-vector('expression',number.leg)#
for(i in 1:number.leg){#
	leg<-round(sequence[i],8)*10^6#
	leg<-paste(leg,"x10",sep="")#
	labs[i]<-substitute(expression(LEG^-6),list(LEG=leg))[2]#
}#
par(mar=c(5,5,5,7))#
image(z=MatrixSD,x=as.numeric(camerawidth)*2,y=as.numeric(callwidth)*2#
			, col=COLred#
			, xlab=expression(paste("Sensor width, ",theta))#
			, ylab=expression(paste("Signal width, ",alpha))#
			, axes=FALSE#
			,main="")#
mtext(side=2,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
mtext(side=1,at=c(0,pi,2*pi),text=expression(0, pi, 2*pi))#
image.plot(MatrixSD, col=COLred, legend.only=TRUE,legend.line = 1,#
		axis.args = list(#
			at=seq(min(MatrixSD),max(MatrixSD),8*10^-7),#
			labels = labs,cex.axis=0.75#
		)#
		)#
box()#
#
dev.off()
